<!DOCTYPE html>
<html>
<head>
	<title>排序技术</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">
    <style type="text/css">
    body{
        font-family: '楷体'
    }
p{
    text-indent: 20px;
    font-family: '楷体'
}

</style>
</head>
<body style="background:#CDB38B;margin-bottom:100px ">
	<h1>第1章 数据结构与算法</h1>
	<h2>1.8 排序技术</h2>
	<h3>1.8.1 交换类排序法</h3>
	<small>所谓排序是指将一个无序序列整理成按值非递减顺序排列的有序序列。<br>
        排序的方法有很多，根据待排序序列的规模以及对数据处理的要求，可以采用不同的排序方法。<br>
        本节主要介绍一些常用的排序方法。
    排序可以在各种不同的存储结构上实现。<br>
    在本节所介绍的排序方法中，其排序对象一般认为是顺序存储的线性表，在程序设计语言中就是一维数组。<br>
    交换类排序法就是借助数据元素之间的互相交换进行排序的一种方法。<br>常见的交换类排序法有冒泡排序法和快速排序法。</small>
	<h4>1.冒泡排序法
    </h4>
	
	<p>冒泡排序法是一种最简单的交换类排序方法，它是通过两两相邻数据元素的交换逐步将线性表变成有序。<br>
    冒泡排序法的基本过程如下：<br>
    首先，从表头开始往后扫描线性表，如果相邻的两个数据元素，前面的元素大于后面的元素，则将它们交换，并称为消去了一个逆序。在扫描过程中，线性表中最大的元素不断地往后移动，最后，被交换到了表的末端。此时，该元素就已经排好序了。<br>
    然后，从后到前扫描剩下的线性表，如果相邻两个数据元素，后面的元素小于前面的元素，则将它们交换，这样就又消去了一个逆序。在扫描过程中，最小的元素不断地往前移动，最后，被换到了线性表的第一个位置，则认为该元素已经排好序了。<br>
    对剩下的线性表重复上述过程，直到剩下的线性表变空为止，表示线性表排序完成。<br>
     冒泡排序每一遍的从前往后扫描都把排序范围内的最大元素沉到了表的底部，每一遍的从后往前扫描，都把排序范围内的最小元素像气泡一样浮到了表的最前面。冒泡排序的名称也由此而来。<br><br>
    在最坏情况下，对长度为n的线性表排序，冒泡排序需要经过n/2遍的从前往后的扫描和n/2遍的从后往前扫描，需要比较的次数为n（n-1）/2。<br>
    <br>图1-27是一个冒泡排序法的例子，对（4，1，6，5，2，3）这样一个6个元素组成的线性表排序。图中每一遍结果中方括号“［ ］”外的元素是已经排好序的元素，方括号“［ ］”内的元素是还未排好序的元素，可以看到，方括号“［ ］”的范围在逐渐减小。具体的说明如下所述。 <br>
    第一遍的从前往后扫描：首先比较“4”和“1”，前面的元素大于后面的元素，这是一个逆序，两者交换（图中用双向箭头表示）。交换后接下来是“4”和“6”比较，不需要交换。然后“6”与“5”比较，这是一个逆序，则相互交换。“6”再与“2”比较，交换。“6”再与“3”比较，交换。这时，排序范围内（即整个线性表）的最大元素“6”已经到达表的底部，它已经到达了它在有序表中应有的位置。
    第一遍的从前往后扫描的最后结果为（1，4，5，2，3，6）。<br>
    第一遍的从后往前扫描：由于数据元素“6”已经排好序，因此，现在的排序范围为（1，4，5，2，3）。先比较“3”和“2”，不需要交换。比较“2”和“5”， 后面的元素小于前面的元素，这是一个逆序，互相交换。比较“2”和“4”， 这是一个逆序，互相交换。比较“2”和“1”，不需要交换。此时，排序范围内（1，4，5，2，3）的最小元素“1”已经到达表头，它已经到达了它在有序表中应有的位置。第一遍的从后往前扫描的最后结果为（1，2，4，5，3，6）。
    第二遍的排序过程略。
    <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp;图1-27 冒泡排序示例  <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-27.jpg" style="width:100%;border-radius: 10px;">
  </p>

<h4>2.快速排序法</h4>
<p> 由于冒泡排序法在扫描过程中只对相邻两个元素进行比较，因此，互换两个相邻元素时只能消除一个逆序。<br>如果通过两个（不相邻）元素的交换，能够消除线性表中的多个逆序，就会大大加快排序的速度。下面介绍的快速排序法可以实现通过一次交换而消除多个逆序。
    快速排序法是冒泡排序法的一种改进，也是一种互换类的排序方法，但由于它比冒泡排序法的速度快，因此称为快速排序法。<br><br>
    快速排序的基本思想是：<br>在待排序的n个元素中取一个元素K（通常取第一个元素），以元素K作为分割标准，把所有小于K元素的数据元素都移到K前面，把所有大于K元素的数据元素都移到K后面。这样，以K为分界线，把线性表分割为两个子表，这称为一趟排序。然后，对K前后的两个子表分别重复上述过程。继续下去，直到分割的子表的长度为1为止，这时，线性表已经是排好序的了。<br>
    第一趟快速排序的具体做法是：附设两个指针low和high，它们的初值分别指向线性表的第一个元素（K元素）和最后一个元素。首先从high所指的位置向前扫描，找到第一个小于K元素的元素并与K元素互相交换。然后从low所指位置起向后扫描，找到第一个大于K元素的数据元素并与K元素交换。重复这两步，直到low=high为止。<br>
    图1-28是一个冒泡排序法的例子。初始状态下，low指针指向第一个元素45，high指针指向最后一个元素49。首先从high所指的位置向前扫描，找到第一个比45小的元素，即找到26时，26与45交换位置，此时low指针指向元素26，high指针指向元素45；然后从low所指位置起向后扫描，找到第一个比45大的元素，即找到61时，61与45交换位置，此时low指针指向元素45，high指针指向元素61；重复这两步，直到low=high为止。所以第一趟排序后的结果为（26，30，12，45，74，82，61，49）。
    以后的排序方法与第一趟的扫描过程一样，直到最后的排序结构为有序序列为止。 
     <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp;图1-28 快速排序示例 <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-28.jpg" style="width:100%;border-radius: 10px;">
    快速排序的平均时间效率最高为O（nlog2n），最坏情况下，即每次划分，只得到一个子序列，时间效率为O（n2）。
    快速排序被认为是目前所有排序算法中最快的一种。但若初始序列有序或者基本有序时，快速排序蜕化为冒泡排序。 </p>

<h3>1.8.2 插入类排序法
</h3>
<small>插入排序是指将无序序列中的各元素依次插入到有序的线性表中。</small>
<p>1.简单插入排序法  <br> <br>
    简单插入排序是把n个待排序的元素看成是一个有序表和一个无序表。 <br>开始时，有序表只包含一个元素，而无序表包含另外n-1个元素，每次取无序表中的第一个元素插入到有序表中的正确位置，使之成为增加一个元素的新的有序表。 <br>插入元素时，插入位置及其后的记录依次向后移动。最后有序表的长度为n，而无序表为空，此时排序完成。 <br>
    简单插入排序过程如图1-29所示。 图中方括号“［ ］”内为有序的子表，方括号“［ ］”外为无序的子表，每次从无序子表中取出第一个元素插入到有序子表中。 <br>
    开始时，有序表只包含一个元素48，而无序表包含另外其他7个元素。 <br>
    当i=2时，即把第2个元素37插入到有序表中，37比48小，所以在有序表中的序列为［ 37，48 ］； <br>
    当i=3时，即把第3个元素65插入到有序表中，65比前面2个元素大，所以在有序表中的序列为［ 37，48，65］； <br>
    当i=4时，即把第4个元素96插入到有序表中，96比前面3个元素大，所以在有序表中的序列为［ 37，48，65，96］； <br>
    当i=5时，即把第5个元素75插入到有序表中，75比前面3个元素大，比96小，所以在有序表中的序列为［ 37，48，65，75，96］； <br>
    以此类推，直到所以的元素都插入到有序序列中。  <br>
 <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp;  图1-29 简单插入排序过程 <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-29.jpg" style="width:100%;border-radius: 10px;">
    在最好情况下，即初始排序序列就是有序的情况下，简单插入排序的比较次数为n-1次，移动次数为0次；在最坏情况下，即初始排序序列是逆序的情况下，比较次数为n（n-1）/2，移动次数为n（n-1）/2。 <br>假设待排序的线性表中的各种排列出现的概率相同，可以证明，其平均比较次数和平均移动次数都约为n2/4，因此直接插入排序算法的时间复杂度为O（n2）。 <br>
    在简单插入排序中，每一次比较后最多移掉一个逆序，因此，这种排序方法的效率与冒泡排序法相同。 <br> <br>
2.希尔排序法 <br> <br>
    希尔排序（Shell Sort）也是一种插入类排序的方法，但在时间效率上较简单插入排序有较大的改进。 <br>
    希尔排序的基本思想是：将整个无序序列分割成若干个小的子序列分别进行插入排序。 <br>
    子序列的分割方法为：将相隔某个增量d的元素构成一个子序列。在排序过程中，逐次减小这个增量，最后当d减至1时，进行一次插入排序，排序就完成。 <br>
    增量序列一般取dt=n/2k（k=1，2，…，[log2n]），其中n为待排序序列的长度。 <br>
希尔排序过程如图1-30所示。此序列共有10个数据，即n=10，则增量d1=10/2=5，将所有距离为5倍数的元素放在一组中，组成了一个子序列，即各子序列为（48，13）、（37，26）、（64，50）、（96，54）、（75，5），对各子序列进行从小到大的排序后，得到第一趟排序结果（13，26，50，54，5，48，37，64，96，75）。 <br>
    接着增量d2=d1/2=5/2=2，将所有距离为2倍数的元素放在一组中，组成了一个子序列，即各子序列为（13，54，37，75）、（26，5，64）、（50，48，96），对各子序列进行从小到大的排序后，得到第二趟排序结果（13，5，48，37，26，50，54，64，96，75）。 <br>
以此类推，直到得到最终结果。 
    <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp; 图1-30 希尔排序过程 <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-30.jpg" style="width:100%;border-radius: 10px;">
   <br>在希尔排序过程中，虽然对于每一个子表采用的仍是插入排序，但是，在子表中每进行一次比较就有可能移去整个线性表中的多个逆序，从而改善了整个排序过程的性能。
    希尔排序的效率与所选取的增量序列有关。在最坏情况下，希尔排序所需要的比较次数为O（n1.5）。 
</p>


<h3>1.8.3 选择类排序法
<br><br>
1.简单选择排序法
    </h3>
    <small>常用的选择类排序法有两种：简单选择排序法和堆排序法。</small>

<p> 简单选择排序法的基本思想是：<br>首先从所有n个待排序的数据元素中选择最小的元素，将该元素与第1个元素交换，再从剩下的n-1个元素中选出最小的元素与第2个元素交换。重复这样的操作直到所有的元素有序为止。<br>
    图1-31所示为对初始状态为（73，26，41，5，12，34）的序列进行简单选择排序的过程。图中方括号“［ ］”内为有序的子表，方括号“［ ］”外为无序的子表，每次从无序子表中取出最小的一个元素加入到有序子表的末尾。<br>
    具体操作步骤如下：<br>
    (1)从这6个元素中选择最小的元素5，将5与第1个元素交换，得到有序序列［ 5 ］；<br>
    (2)从剩下的5个元素中挑出最小的元素12，将12与第2个元素交换，得到有序列［ 5，12 ］；<br>
    (3)从剩下的4个元素中挑出最小的元素26，将26与第3个元素交换，得到有序序列［ 5，12，26 ］；<br>
    (4)依此类推，直到所有的元素都有序地排列到有序的子表中。 <br><br>

<br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp; 图1-31 简单选择排序  <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-31.jpg" style="width:100%;border-radius: 10px;">




    简单选择排序法在最坏的情况下需要比较n（n-1）/2次。<br><br>
2.堆排序法<br>
（1）堆的定义<br>
    若有n个元素的序列（h1，h2，…，hn），将元素按顺序组成一棵完全二叉树，当且仅当满足下列条件时称为堆。<br>
    hi≥h2i 或 hi≤h2i <br>
    hi≥h2i+1···hi≤h2i+1<br>
    其中，i=1，2，3，…，n/2，前者情况称为大根堆，所有结点的值大于或等于左右子结点的值；后者情况称为小根堆，所有结点的值小于或等于左右子结点的值。本节只讨论大根堆的情况。<br>
    在实际处理中，可以用一维数组H（1：n）来存储堆序列中的元素，也可以用完全二叉树来直观地表示堆的结构。例如，序列（91，85，53，36，47，30，24，12）是一个堆，则它对应的完全二叉树如图1-32所示。 
<br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp; 图1-32 堆顶元素为最大的堆  <br>
    <img src="file:///android_asset/local_html/local_imgs/T1-32.jpg" style="width:100%;border-radius: 10px;">
    由图1-32可以看出，在用完全二叉树表示堆时，树中所有非叶子结点值均不小于其左、右子树的根结点值，因此，堆顶（完全二叉树的根结点）元素必是序列的n个元素中的最大项。<br><br>
（2）调整建堆<br>
    在具体讨论堆排序法之前，先看这样一个问题：在一棵具有n个结点的完全二叉树[用一维数组H（1：n）表示]中，假设结点H（m）的左右子树均为堆，现要将以H（m）为根结点的子树也调整为堆。这就是调整建堆的问题。<br>
    例如，假设图1-33（a）是某完全二叉树的一棵子树。在这棵子树中，根结点47的左、右子树均为堆，为了将整个子树调整成堆，首先将根结点47与其左、右子树的根结点进行比较，此时由于左子树根结点91大于右子树根结点53，且它又大于根结点47，因此，根据堆的条件，应将元素47与91交换，如图1-33（b）所示。经过一次交换后，破坏了原来左子树的堆结构，需要对左子树再进行调整，将元素85与47进行交换，调整后的结果如图1-33（c）所示。 <br>
    <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp;   图1-33 调整建堆<br>
    <img src="file:///android_asset/local_html/local_imgs/T1-33.jpg" style="width:100%;border-radius: 10px;">
 
    由上例可以看出，在调整建堆的过程中，总是将根结点值与左右子树的根结点值进行比较，若不满足堆的条件，则将左右子树根结点值中的大者与根结点值进行交换。这个调整过程一直做到所有子树均为堆为止。<br>
（3）堆排序<br><br>
    堆排序的方法为：首先将一个无序序列建成堆，然后将堆顶元素（序列中的最大项）与堆中的最后一个元素交换。不考虑已经换到最后的那个元素，将剩下的n-1个元素重新调整为堆，重复执行此操作，直到所有元素有序为止。<br>
    对于数据元素较少的线性表来说，堆排序的优越性并不明显，但对于大量的数据元素来说，堆排序是很有效的。在最坏情况下，堆排序需要比较的次数为O(nlog2n)。</p>
    <h3>1.8.4 排序方法比较
  </h3>
    <small>常用的排序方法的时间和空间复杂度的比较如表1-6所示。 </small>
    <p>表1-6 常用排序方法时间、空间复杂度比较,上表中未包括希尔排序，因为希尔排序的时间效率与所取的增量序列有关，如果增量序列为：<br>
    d1＝n/2，di+1＝di/2 （n为等待排序序列的元素个数）。<br>
    则在最坏情况下，希尔排序所需要的比较次数为O(n1.5)。</p>
    <br> <br>
        &nbsp; &nbsp; &nbsp; &nbsp;   表1-6 常用排序方法<br>
    <img src="file:///android_asset/local_html/local_imgs/B1-6.jpg" style="width:100%;border-radius: 10px;">
</body>
</html>






   


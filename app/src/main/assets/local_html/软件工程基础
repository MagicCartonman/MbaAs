<!DOCTYPE html>
<html>
<head>
	<title>算法</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, initial-scale=1">

</head>
<body style="background:#CDB38B;margin-bottom:100px ">

<p>
    第3章 软件工程基础
</p>
<p>
    
</p>
<p>
    3.1 软件工程基本概念
</p>
<p style="text-align: center;">
    <strong>3.1.1 软件的定义及软件的特点</strong>
</p>
<p>
    1.软件的定义
</p>
<p>
    &nbsp; &nbsp; 我国国家标准（简称国标，GB）中对计算机软件（Software）完整的定义是： 软件是与计算机系统操作有关的计算机程序、规程、规则，以及可能有的文件、文档及数据。
</p>
<p>
    &nbsp; &nbsp; 计算机软件由两部分组成：机器可执行的程序和数据；机器不可执行的，与软件开发、运行、维护、使用等有关的文档。
</p>
<p>
    &nbsp; &nbsp; 计算机软件是由程序、数据及相关文档构成的完整集合，它与计算机硬件一起组成计算机系统。
</p>
<p>
    2.软件的特点
</p>
<p>
    &nbsp; &nbsp; 软件具有以下特点：
</p>
<p>
    &nbsp; （1）软件是一种逻辑实体，具有抽象性
</p>
<p>
    &nbsp; &nbsp; 软件区别于一般的、看得见摸得着的、属于物理实体的工程对象，人们只能看到它的存储介质，而无法看到它本身的形态。只有运用逻辑思维才能把握软件的功能和特性。
</p>
<p>
    &nbsp; （2）软件没有明显的制作过程
</p>
<p>
    &nbsp; &nbsp; 硬件研制成功后，在重复制造时，要进行质量控制，才能保证产品合格；而软件一旦研制成功，就可以得到大量的、成本极低的，并且完整精确的拷贝。因此，软件的质量控制必须着重于软件开发。
</p>
<p>
    &nbsp; &nbsp;（3）软件在使用期间不存在磨损、老化问题
</p>
<p>
    &nbsp; &nbsp; 软件价值的损失方式是很特殊的，软件会为了适应硬件、环境以及需求的变化而进行修改，而这些修改不可避免地引入错误，导致软件失效率升高，从而使得软件退化。当修改的成本变得难以接受时，软件就会被抛弃。
</p>
<p>
    &nbsp; &nbsp;（4）对硬件和环境具有依赖性
</p>
<p>
    &nbsp; &nbsp; 软件的开发、运行对计算机硬件和环境具有不同程度的依赖性，这给软件的移植带来了新的问题。
</p>
<p>
    &nbsp; &nbsp;（5）软件复杂性高，成本昂贵
</p>
<p>
    &nbsp; &nbsp; 软件涉及人类社会的各行各业、方方面面，软件开发常常涉及其他领域的专业知识。软件开发需要投入大量、高强度的脑力劳动，成本高，风险大。现在软件的成本已大大地超过了硬件的成本。
</p>
<p>
    &nbsp; &nbsp;（6）软件开发涉及诸多的社会因素
</p>
<p>
    &nbsp; &nbsp; &nbsp;软件除了本身具有的复杂性以外，在开发过程中，涉及的社会因素也是非常复杂的。
</p>
<p>
    3.软件的分类
</p>
<p>
    &nbsp; &nbsp; 计算机软件按功能分为应用软件、系统软件、支撑软件（或工具软件）。
</p>
<p>
    &nbsp; （1）系统软件——是管理计算机的资源，提高计算机的使用效率，为用户提供各种服务的软件。它是计算机系统必不可少的一个组成部分。&nbsp;
</p>
<p>
    例如，操作系统（OS）、数据库管理系统（DBMS）、编译程序、汇编程序、网络软件、设备驱动程序以及通信处理程序等等。系统软件是最靠近计算机硬件的软件。
</p>
<p>
    &nbsp; （2）应用软件——为了应用于特定的领域而开发的软件。
</p>
<p>
    例如，工程和科学计算软件、嵌入式软件、计算机辅助设计／制造(CAD／CAM)软件、系统仿真软件、人工智能软件等 软件属于应用软件。
</p>
<p>
    &nbsp; （3）支撑软件——介于系统软件和应用软件之间，协助用户开发软件的工具型软件，其中包括帮助程序人员开发和维护软件产品的工具软件，也包括帮助管理人员控制开发进程和项目管理的工具软件。
</p>
<p>
    &nbsp; &nbsp; &nbsp;例如，Dephi、PowerBuilder等。
</p>
<p>
    <br/>
</p>
<p>
    3.1.2 软件危机
</p>
<p>
    软件危机泛指在计算机软件的开发和维护过程中所遇到的一系列严重问题。这些问题绝不仅仅是不能正常运行的软件才具有的，实际上，几乎所有软件都不同程度地存在这些问题。
</p>
<p>
    &nbsp; &nbsp; &nbsp;具体地说，在软件开发和维护过程中，软件危机主要表现在以下几个方面：
</p>
<p>
    &nbsp; （1）不能满足软件需求的增长。经常会有用户对系统不满意的情况出现。
</p>
<p>
    &nbsp; （2）软件开发的成本和进度无法控制。开发成本过高以及开发周期过长的情况经常发生。
</p>
<p>
    &nbsp; （3）软件质量难以保证。
</p>
<p>
    &nbsp; （4）软件可维护程度低或者不可维护。
</p>
<p>
    &nbsp; （5）软件的成本不断提高。
</p>
<p>
    &nbsp; （6）软件开发生产率的提高赶不上硬件的发展和应用需求的增长。
</p>
<p>
    &nbsp; &nbsp; 总之，可以将软件危机归结为成本、质量、生产率等问题。
</p>
<p>
    <br/>
</p>
<p>
    3.1.3 软件工程
</p>
<p>
    1.软件工程的定义
</p>
<p>
    &nbsp; &nbsp; 软件工程概念的出现源自软件危机。通过认真研究消除软件危机的途径，逐渐形成了一门新兴的工程学科——计算机软件工程学（简称为软件工程）。
</p>
<p>
    &nbsp; &nbsp; 国家标准（GB）中指出：软件工程是指应用于计算机软件的定义、开发和维护的一整套方法、工具、文档、实践标准和工序。
</p>
<p>
    &nbsp; &nbsp; 软件工程包含3个要素：方法、工具和过程。
</p>
<p>
    &nbsp; &nbsp; 方法：方法是完成软件开发各项任务的技术手段。
</p>
<p>
    &nbsp; &nbsp; 工具：工具支持软件的开发、管理、文档生成。
</p>
<p>
    &nbsp; &nbsp; 过程：过程支持软件开发的各个环节的控制、管理。
</p>
<p>
    2.软件工程的目标和原则
</p>
<p>
    &nbsp; &nbsp; 软件工程的目标是：在给定成本、进度的前提下，开发出具有有效性、可靠性、可理解性、可维护性、可重用性、可适应性、可移植性、可追踪性和可互操作性且满足用户需求的产品。为了实现其目标，软件工程提出了工程化的思想。
</p>
<p>
    &nbsp; &nbsp; 工程是对技术（或社会）实体的分析、设计、建造、验证和管理。软件工程从管理和技术两方面指导软件开发。它们各自包含的内容如图3-1所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>

<p>
   
     图3-1 软件工程的力量和技术性研究&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-1.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp; &nbsp; 软件工程研究内容：
</p>
<p>
    &nbsp; （1）软件开发模型。如：瀑布模型、增量模型、迭代模型。
</p>
<p>
    &nbsp; （2）软件开发方法。如：面向过程方法、面向数据方法、面向对象方法。
</p>
<p>
    &nbsp; （3）软件支持过程。如：CASE工具Rose、北大青鸟系统、PowerDesigner。
</p>
<p>
    &nbsp; （4）软件管理过程。如：ISO9000、CMM、软件企业文化。
</p>
<p>
    &nbsp; &nbsp; 例如，要开发一个软件系统（如图书馆信息系统），为了完成这项任务，首先要选择软件开发模型，确定开发方法、准备开发工具、设计开发环境和运行环境，然后进行需求分析、设计、编程、测试、试运行、正式运行、验收和交付，最后是系统维护或系统升级换代。这样就按照所选择的开发模型，走完了软件的一个生命周期，这一系列的软件开发过程和管理过程，就是软件工程。
</p>
<p>
    3.软件工程的原则
</p>
<p>
    &nbsp; &nbsp; 软件工程发展到现在，已经总结出若干基本原则，所有的软件项目都应遵循这些原则，以达到软件工程的目标。软件工程原则包括抽象、信息隐蔽、模块化、局部化、确定性、一致性、完备性和可验证性。
</p>
<p>
    &nbsp; （1）抽象。抽取事物最基本的特性和行为，忽略非本质细节。采用分层次抽象，自顶向下，逐层细化的办法控制软件开发过程的复杂性。
</p>
<p>
    &nbsp; （2）信息隐蔽。采用封装技术，将程序模块的实现细节隐藏起来，使模块借口尽量简单。
</p>
<p>
    &nbsp; （3）模块化。模块是程序中相对独立的成分，一个独立的编程单位，应有良好的接口定义。模块的大小要适中，模块过大会使模块内部的复杂性增加，不利于对模块的理解和修改，也不利于模块的调试和重用。模块太小会导致整个系统表示过于复杂，不利于控制系统的复杂性。
</p>
<p>
    &nbsp; （4）局部化。要求在一个物理模块内集中逻辑上相互关联的计算机资源，保证模块之间具有松散的耦合关系，模块内部具有较强的内聚性，这有助于控制分解的复杂性。
</p>
<p>
    &nbsp; （5）确定性。软件开发过程中所有概念的表达应是确定的、无歧义的、规范的。这有助于人与人的交互不会产生误解和遗漏，以保证整个开发工作的协调一致。 &nbsp; &nbsp;&nbsp;
</p>
<p>
    &nbsp; （6）一致性。包括程序、数据和文档的整个软件系统的各模块应使用已知的概念、符号和术语；程序内外部接口应保持一致，系统规格说明与系统行为应保持一致。
</p>
<p>
    &nbsp; （7）完备性。软件系统不丢失任何重要成分，完全实现系统所要求的功能。
</p>
<p>
    &nbsp; （8）可验证性。开发大型软件系统需要对系统自顶向下，逐层分解。系统分解应遵循容易检查、测评、评审的原则，以确保系统的正确性。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.1.4 软件过程
</p>
<p>
    ISO 9000 定义：软件过程是把输入转化为输出的一组彼此相关的资源和活动。
</p>
<p>
    &nbsp; &nbsp; 软件过程是为了获得高质量软件所需要完成的一系列任务的框架，它规定了完成各项任务的工作步骤。
</p>
<p>
    &nbsp; &nbsp; 软件过程所进行的基本活动主要包含如下4种。
</p>
<p>
    &nbsp; （1）P(Plan，软件规格说明)。规定软件的功能及其运行时的限制。
</p>
<p>
    &nbsp; （2）D（Do，软件开发）。软件开发或软件设计与实现，生产满足规格说明的软件
</p>
<p>
    &nbsp; （3）C（Check，软件确认）确认能够满足用户提出的要求
</p>
<p>
    &nbsp; （4）A（Action，软件演进）。为满足客户要求的变更，软件必须在使用的过程中不断演进
</p>
<p>
    &nbsp; &nbsp; 软件过程所使用的资源主要指人员、时间及软、硬件工具等。
</p>
<p>
    &nbsp; &nbsp; 从软件开发的观点看，软件工程过程是使用适当的资源为开发软件进行的一组开发活动，在过程结束时，将输入（用户要求）转化为输出（软件产品），如图3-2所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>    3-2 软件工程过程示意图&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-2.jpg" style="width:100%;border-radius: 10px;">
  
</p>
<p>
    &nbsp; &nbsp; 软件工程的过程应确定运用方法的顺序、应该交付的文档资料、为保证软件质量和协调变化所需要采取的管理措施，以及软件开发各个阶段完成的任务。为了获得高质量的软件产品，软件工程过程必须科学、有效。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.1.5 软件生命周期
</p>
<p>
    软件生命周期是指软件产品从提出、实现、使用、维护到停止使用、退役的过程。也就是说，软件产品从其概念提出开始，到该软件产品不能使用为止的整个时间段都属于软件生命周期。
</p>
<p>
    &nbsp; &nbsp; 软件生命周期通常包括可行性研究和项目开发计划、需求分析、概要设计、详细设计、编码、测试、维护等活动。一般分为3个阶段。
</p>
<p>
    &nbsp; （1）软件定义阶段：该阶段的主要任务是确定软件开发工作必须完成的目标以及工程的可行性。
</p>
<p>
    &nbsp; （2）软件开发阶段：该阶段的任务是具体完成设计和实现定义阶段所定义的软件，通常包括总体设计、详细设计、编码和测试。其中总体设计和详细设计又称为系统设计，编码和测试又称为系统实现。
</p>
<p>
    &nbsp; （3）软件维护阶段：改阶段的任务是使软件在运行中持久地满足用户的需要。
</p>
<p>
    软件生命周期各个阶段的活动可以有重复，执行时也可以有迭代，如图3-3所示。&nbsp;
</p>
<p>
    
   &nbsp;图3-3软件生命周期&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-3.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp; &nbsp; 在图3-3中的软件生命周期各阶段的主要任务是：
</p>
<p>
    &nbsp; （1）问题定义。确定要求解决的问题是什么。
</p>
<p>
    &nbsp; （2）可行性研究与计划制定。决定该问题是否存在一个可行的解决办法，指定完成开发任务的实施计划。
</p>
<p>
    &nbsp; （3）需求分析。对待开发软件提出需求进行分析并给出详细定义。编写软件规格说明书及初步的用户手册，提交评审。
</p>
<p>
    &nbsp; （4）软件设计。通常又分为概要设计和详细设计两个阶段，给出软件的结构、模块的划分、功能的分配以及处理流程。该阶段提交评审的文档有概要设计说明书、详细设计说明书和测试计划初稿。
</p>
<p>
    &nbsp; （5）软件实现。在软件设计的基础上编写程序。该阶段完成的文档有用户手册、操作手册等面向用户的文档，以及为下一步作准备而编写的单元测试计划。
</p>
<p>
    &nbsp; （6）软件测试。在设计测试用例的基础上，检验软件的各个组成部分。编写测试分析报告。
</p>
<p>
    &nbsp; （7）运行维护。将已交付的软件投入运行，同时不断地维护，进行必要而且可行的扩充和删改。&nbsp;
</p>
<p>
    3.1.6 软件开发工具与开发环境
</p>
<p>
    1.软件开发工具
</p>
<p>
    &nbsp; &nbsp; 软件开发工具的产生、发展和完善促进了软件的开发速度和质量的提高。软件开发工具从初期的单项工具逐步向集成工具发展。与此同时，软件开发的各种方法也必须得到相应的软件工具支持，否则方法就很难有效的实施。
</p>
<p>
    2.软件开发环境
</p>
<p>
    &nbsp; &nbsp; 软件工程环境（或软件开发环境）是全面支持软件开发全过程的软件工具集合。这些软件工具按照一定的方法或模式组合起来，支持软件生命周期的各个阶段和各项任务的完成。
</p>
<p>
    &nbsp; &nbsp; 计算机辅助软件工程（Computer Aided Software Engineering，CASE）是当前软件开发环境中富有特色的研究工作和发展方向。CASE将各种软件工具、开发机器和一个存放过程信息的中心数据库组合起来，形成软件工程环境。一个良好的工程环境将最大限度地降低软件开发的技术难度并使软件开发的质量得到保证。
</p>
<p>
    <br/>
</p>
<p style="text-align: center;">
    <strong>3.2 结构化分析方法</strong>
</p>
<p>
    3.2.1 需求分析
</p>
<p>
    目前使用最广泛的软件工程方法学是结构化方法学和面向对象方法学。结构化方法学也称为传统方法学，它采用结构化方法来完成软件开发的各项任务，并使用适当的软件工具或软件工程环境来支持结构化方法的运用。它包括结构化分析（ Structured Analysis ）、结构化设计（ Structured Design ）和结构化程序设计（ Structured Programming ）三部分组成。结构化方法的基本指导思想是自顶向下，逐步求精，它的基本原则是抽象与分解。
</p>
<p>
    &nbsp; &nbsp; 软件需求是指用户对目标软件系统在功能、行为、性能、设计约束等方面的期望。需求分析的任务是发现需求、求精、建模和定义需求的过程。需求分析将创建所需的数据模型、功能模型和控制模型。
</p>
<p>
    &nbsp; &nbsp; 需求分析的过程是开发人员与用户共同协商，明确系统的全部功能、性能以及运行规格，并且使用软件开发人员和用户都能理解的语言准确地表达出来，即完成需求规格说明的过程。
</p>
<p>
    1.需求的定义
</p>
<p>
    &nbsp; &nbsp; 1977年IEEE在《软件工程标准词汇表》中将需求定义为：①用户解决问题或达到目标所需的条件或权能；②系统或系统部件要满足合同、标准、规范或其他正式文档所需要具有的条件或权能；③一种反映①或②所描述的条件或权能的文档说明。
</p>
<p>
    &nbsp; &nbsp; 对软件需求的深入理解是软件开发工作获得成功的前提。需求分析是一件艰巨复杂的工作。因为，只有用户才真正知道自己需要什么，但是他们并不知道怎样用软件实现自己的需求，对软件需求的描述可能不够准确、具体；或者分析员知道怎样用软件实现人们的需求，但是在需求分析开始时他们对用户的需求并不十分清楚，必须与用户不断沟通。
</p>
<p>
    2.需求分析阶段的工作
</p>
<p>
    &nbsp; &nbsp; 概括地说，需求分析阶段的工作可以分为4个方面：需求获取、需求分析、编写需求规格说明书和需求评审。
</p>
<p>
    &nbsp; （1）需求获取
</p>
<p>
    &nbsp; &nbsp; 确定目标系统的各方面需求是需求获取阶段的根本目的。该阶段涉及的主要任务是建立获取用户需求的方法框架，并支持和监控需求获取的过程。
</p>
<p>
    &nbsp; &nbsp; 需求获取涉及的关键问题有：对问题空间的理解；人与人之间的通信；不断变化的需求。
</p>
<p>
    &nbsp; （2）需求分析
</p>
<p>
    &nbsp; &nbsp; 对获取的需求进行分析和综合，最终给出系统的解决方案和目标系统的逻辑模型。
</p>
<p>
    &nbsp; （3）编写需求规格说明书
</p>
<p>
    &nbsp; &nbsp; 需求规格说明书是需求分析的阶段性成果，它可以为用户、分析人员和设计人员之间的交流提供方便，可以直接支持目标系统的确认，又可以作为控制软件开发进程的依据。
</p>
<p>
    &nbsp; &nbsp;（4）需求评审
</p>
<p>
    &nbsp; &nbsp; 在需求分析的最后一步，对需求分析阶段的工作进行复审，验证需求文档的一致性、可行性、完整性和有效性。
</p>
<p>
    3.需求分析方法
</p>
<p>
    &nbsp; &nbsp; &nbsp;需求分析方法可以分为结构化分析方法和面向对象的分析方法两大类。
</p>
<p>
    &nbsp; （1）结构化分析方法
</p>
<p>
    &nbsp; &nbsp; 结构化分析方法主要包括：面向数据流的结构化分析方法（Structured Analysis，SA）、面向数据结构的Jackson系统开发方法（Jackson System Development Method，JSD）和面向数据结构的结构化数据系统开发方法（Data Structured System Development Method，DSSD）。
</p>
<p>
    &nbsp; &nbsp; &nbsp;该方法由数据流和数据字典构成，适于数据处理领域问题。但该方法的一个难点是确定数据流之间的变换，而且数据字典的规模也是一个问题，对数据结构的强调很少。
</p>
<p>
    &nbsp; （2）面向对象的分析方法
</p>
<p>
    &nbsp; &nbsp; 面向对象的分析方法（Object-Oriented Analysis，OOA）中，从需求分析建模的特性来划分，需求分析方法还可以分为静态分析方法和动态分析方法。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.2.2 结构化分析方法
</p>
<p>
    1.关于结构化分析方法
</p>
<p>
    DeMarco对面向数据流的结构化分析方法有如下定义:
</p>
<p>
    使用数据流图（DFD）、数据字典（DD）、结构化英语、判定表和判定树等工具，来建立一种新的、称为结构化规格说明的目标文档。
</p>
<p>
    SA方法的实质是着眼于数据流、自顶向下、对系统的功能进行逐层分解、以数据流图和数据字典为主要工具，建立系统的逻辑模型。
</p>
<p>
    结构化分析步骤：
</p>
<p>
    （1）通过对用户的调查，以软件的需求为线索，建立当前系统的具体模型；
</p>
<p>
    （2）去掉具体模型中非本质因素，抽象出当前系统的逻辑模型；
</p>
<p>
    （3）根据计算机的特点分析当前系统和目标系统的差别，建立目标系统的逻辑模型；
</p>
<p>
    （4）完善目标系统并补充细节，写出目标系统的软件需求规格说明；
</p>
<p>
    （5）评审直到确认完全符合用户对软件的需求。
</p>
<p>
    2.结构化分析方法的常用工具
</p>
<p>
    （1）数据流图（Data Flow Diagram，DFD）
</p>
<p>
    数据流图是系统逻辑模型的图形表示，即使不是专业的计算机技术人员也容易理解它，因此它是分析员与用户之间极好的通信工具。
</p>
<p>
    数据流图中的主要图形元素与说明如表3-1。&nbsp;
</p>
<p>
    <br/>
</p>
<p> 
  
   
</p>
<p>
    &nbsp;
</p>
<p>
    在数据流图中，对所有的图形元素都进行了命名，它们都是对一些属性和内容抽象的概括。一个软件系统对其数据流图的命名必须有相同的理解，否则将会严重影响以后的开发工作。
</p>
<p>
    一般通过对实际系统的了解和分析后，使用数据流图为系统建立逻辑模型。建立数据流图的步骤如下：
</p>
<p>
    第1步：由外向里，即先画出系统的输入输出，然后画系统的内部。
</p>
<p>
    第2步：自顶向下，即按由上到下的顺序完成顶层、中间层、底层数据流图。
</p>
<p>
    第3步：逐层分解。
</p>
<p>
    描述一个复杂的系统，不可能一下子引进太多的细节。否则用一张数据流图画出所有的数据流和加工，则这张图将是极其庞大而复杂，因而难以绘制，也难以理解。所以必须用分层的方法将一个流程图分解成几个流程图，来分别表示。
</p>
<p>
    （2）数据字典（Data Dictionary,DD）
</p>
<p>
    数据字典是对数据流图中所有元素的定义的集合，是结构化分析的核心。
</p>
<p>
    数据流图和数据字典共同构成系统的逻辑模型，没有数据字典数据流图就不严格，若没有数据流图，数据字典也难于发挥作用。
</p>
<p>
    数据字典中有4种类型的条目：数据流、数据项、数据存储和加工。
</p>
<p>

    在数据字典各条目的定义中，常用符号如表3-2所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>表3-2 数据字典中的符号&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/B3-2.jpg" style="width:100%;border-radius: 10px;">
    
</p>
<p>
    &nbsp;
</p>
<p>
    （3）判定树
</p>
<p>
    判定树又称决策树，是一种描述加工的图形工具适合描述问题处理中具有多个判断，而且每个决策与若干条件有关的事务。
</p>
<p>
    使用判定树进行描述时，应先从问题定义的文字描述中分清哪些是判定的条件，哪些是判定的结论，根据描述材料中的连接词找出判定条件之间的从属关系、并列关系、选择关系，根据它们构造判定树。
</p>
<p>
    （4）判定表
</p>
<p>
    判定表与判定树类似，当数据流图中的加工要依赖于多个逻辑条件的取值，即完成该加工的一组动作是由某一组条件取值的组合而引发的，使用判定表描述比较适宜。
</p>
<p>
    有些加工的逻辑用语言形式不容易表达清楚，而用表的形式则一目了然。如果一个加工逻辑有多个条件、多个操作，并且在不同的条件组合下执行不同的操作，那么可以使用判定表来描述。
</p>
<p>
    判定表能把什么条件下系统应做什么动作准确地表示出来，同时能发现需求的不完整性，如某些条件组合下缺少应采取的动作。也能发现冗余的动作，可将条件合并。但判定表不能描述循环的处理特性，循环处理还需结构化语言。
</p>
<p>
    判定表由4部分组成，如图3-4所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
	 图3-4判定表的组成&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-4.jpg" style="width:100%;border-radius: 10px;">
   
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    其中：
</p>
<p>
    标识为①的左上部称为基本条件项，它列出各种可能的条件；
</p>
<p>
    标识为②的右上部称为条件项，它列出各种可能的条件组合；
</p>
<p>
    标识为③的左下部称为基本动作项，它列出所有的操作；
</p>
<p>
    标识为④的右下部称动作项，它列出在对应的条件组合下所选的操作。
</p>
<p>
    例如：将如下结构化语言示例，表示为判定表。
</p>
<p>
    IF 顾客订额≥1000
</p>
<p>
    IF 顾客信誉好
</p>
<p>
    订单设“优先”标志
</p>
<p>
    ELSE
</p>
<p>
    IF 顾客是老顾客
</p>
<p>
    订单设“优先”标志
</p>
<p>
    ELSE
</p>
<p>
    订单设“正常”标志
</p>
<p>
    ENDIF
</p>
<p>
    ENDIF
</p>
<p>
    ELSE
</p>
<p>
    订单设“正常”标志
</p>
<p>
    ENDIF
</p>
<p>
    判定表表示如表3-3：&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    表3-3 “顾客订单优先级”判定表&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/B3-3.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.2.3 软件需求规格说明书
</p>
<p>
    软件需求规格说明书（Software Requirement Specification，SRS）是需求分析阶段的最后成果，是软件开发过程中的重要文档之一。
</p>
<p>
    &nbsp; （1）软件需求规格说明书的作用
</p>
<p>
    &nbsp; &nbsp; ①便于用户、开发人员进行理解和交流。
</p>
<p>
    &nbsp; &nbsp; ②反映出用户问题的结构，可以作为软件开发工作的基础和依据。
</p>
<p>
    &nbsp; &nbsp; ③作为确认测试和验收的依据。
</p>
<p>
    &nbsp; &nbsp; ④为成本估算和编制计划进度提供基础。
</p>
<p>
    &nbsp; &nbsp; ⑤软件不断改进的基础。
</p>
<p>
    &nbsp; （2）软件需求规格说明书的标准
</p>
<p>
    &nbsp; &nbsp; 软件需求规格说明书是确保软件质量的有力措施，衡量软件需求规格说明书质量好坏的标准，标准的优先级及标准的内涵如表3-4所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    表3-4 软件需求规格说明书的标准
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; （3）软件需求规格说明书的内容
</p>
<p>
    &nbsp; &nbsp; 软件需求规格说明应重点描述软件的目标，软件的功能需求、性能需求、外部接口、属性及约束条件等。功能需求是软件需求规格说明，给出软件要执行什么功能的详尽描述。性能需求是指定量的描述软件系统应满足的具体性能需求，即各种软件功能的速度、响应时间、回复时间。外部接口指软件如何与人、系统的硬件及其他硬件和其他软件进行交互。属性是指与软件有关的质量属性，如正确性、可用性、可靠性、安全性、可维护性等。约束条件包括影响软件实现的各种设计约束，如使用的标准、编程语言、数据库完整性方针、资源限制、运行环境等方面的要求。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p style="text-align: center;">
    <strong>3.3 结构化设计方法</strong>
</p>
<p>
    3.3.1 软件设计概述
</p>
<p>
    在需求分析阶段，使用数据流图和数据字典等工具已经建立了系统的逻辑模型，解决了“做什么”的问题。接下来的软件设计阶段，是解决“怎么做”的问题。下图表明了结构化设计与结构化分析的关系。 本节主要介绍软件工程的软件设计阶段。软件设计可分为两步：概要设计和详细设计。
</p>
<p>
    1. 软件设计的基础
</p>
<p>
    &nbsp; &nbsp; 软件设计的基本目标是用比较抽象概括的方式确定目标系统如何完成预定的任务，也就是说，软件设计是确定系统的物理模型。
</p>
<p>
    &nbsp; &nbsp; 软件设计是开发阶段最重要的步骤。从工程管理的角度来看可分为两步：概要设计和详细设计。按工程管理角度划分，软件设计包括概要设计和详细设计；从技术观点来看，软件设计包括软件结构设计、数据设计、接口设计、过程设计。如表3-5所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    
      表3-5软件设计的划分
    <img src="file:///android_asset/local_html/local_imgs/B3-5.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp;
</p>
<p>
    2.软件设计的基本原理和原则
</p>
<p>
    &nbsp; &nbsp; 软件设计过程中应该遵循的基本原理和原则如下所述。
</p>
<p>
    &nbsp; （1）模块化
</p>
<p>
    &nbsp; &nbsp; 模块化是解决一个复杂问题时自顶向下逐层把软件系统划分成若干模块的过程。它是软件解决复杂问题所具备的手段，不但可以降低问题复杂性，还可以减少开发工作量从而降低开发成本，提供软件生产率。
</p>
<p>
    &nbsp; &nbsp; 在软件的体系结构中，模块是可组合、分解和更换的单元，具有以下几种基本属性：
</p>
<p>
    &nbsp; &nbsp; 接口：指模块的输入输出。
</p>
<p>
    &nbsp; &nbsp; 功能：模块实现的功能。
</p>
<p>
    &nbsp; &nbsp; 逻辑：内部如何实现及所需数据。
</p>
<p>
    &nbsp; &nbsp; 状态：模块的运行环境，调用与被调用关系。
</p>
<p>
    &nbsp; &nbsp; 逻辑属性反映内部特性，其它属性反映模块的外部特性。
</p>
<p>
    &nbsp; （2）抽象
</p>
<p>
    &nbsp; &nbsp;抽象是人类在认识复杂现象的过程中使用的最强有力的思维工具。抽象就是抽出事物的本质特性，将相似的方面集中和概括起来，而暂时不考虑它们的细节，暂时忽略它们之间的差异。抽象是认识复杂现象过程中使用的思维工具。
</p>
<p>
    &nbsp; &nbsp; 软件结构顶层的模块，控制了系统主要功能并影响全局，底层模块完成具体的处理。在进行软件设计时，抽象与逐步求精、模块化密切相关，可提高软件的可理解性。
</p>
<p>
    &nbsp; （3）信息隐藏
</p>
<p>
    &nbsp; &nbsp; 信息隐藏是指在设计和确定模块时，使得一个模块内包含的信息（过程和数据），对于不需要这些信息的其他模块来说，是不可访问的。它为软件系统的修改、测试及以后的维护都带来好处。
</p>
<p>
    &nbsp; （4）模块独立性
</p>
<p>
    &nbsp; &nbsp; 指每个模块只完成系统要求的独立的子功能，并且与其它模块的联系量最少且接口简单。
</p>
<p>
    &nbsp; &nbsp; 模块独立性的高低是设计好坏的关键，而设计又是决定软件质量的关键环节。
</p>
<p>
    模块的独立程度包括两个度量准则：内聚性和耦合性。
</p>
<p>
    &nbsp; &nbsp; ①耦合性：指软件系统结构中各模块间相互联系紧密程度的一种度量。模块间耦合高低取决于接口的复杂性、调用的方式及传递的信息。
</p>
<p>
    &nbsp; &nbsp; ②内聚性：指模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密 程度的度量。
</p>
<p>
    &nbsp; &nbsp; 一般来说，要求模块之间的耦合尽可能弱，即模块尽可能独立，且要求模块的内聚程度尽可能高。内聚性和耦合性是一个问题的两个方面，耦合性程度弱的模块，其内聚程度一定高。
</p>
<p>
    &nbsp; &nbsp; 内聚和耦合都是进行模块化设计的有力工具，但是实践表明内聚更重要，应该把更多注意力集中到提高模块的内聚程度上。
</p>
<p>
    3. 结构化设计方法
</p>
<p>
    &nbsp; &nbsp; 与结构化需求分析方法相对应的是结构化设计方法。结构化设计就是采用最佳的可能方法设计系统的各个组成部分以及各成分之间的内部联系的技术。也就是说结构化设计是这样一个过程，它决定用哪些方法把哪些部分联系起来，才能解决好某个具体有清楚定义的问题。
</p>
<p>
    &nbsp; &nbsp; 结构化设计方法的基本思想是将软件设计成由相对独立、单一功能的模块组成的结构。下面重点以面向数据流的结构化方法为例详细介绍结构化设计方法。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.3.2 概要设计
</p>
<p>
    1.概要设计的任务
</p>
<p>
    &nbsp; &nbsp; 概要设计又称总体设计，软件概要设计的基本任务如下所述。
</p>
<p>
    &nbsp; （1）设计软件系统结构
</p>
<p>
    &nbsp; &nbsp; 为了实现目标系统，先进行软件结构设计，具体过程如图3-5所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    图3-5 软件系统结构设计过程&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; （2）数据结构及数据库设计
</p>
<p>
    &nbsp; &nbsp; 数据设计是实现需求定义和规格说明中提出的数据对象的逻辑表示。
</p>
<p>
    &nbsp; （3）编写概要设计文档
</p>
<p>
    &nbsp; &nbsp; 概要设计阶段的文档有概要设计说明书、数据库设计说明书和集成测试计划等。
</p>
<p>
    &nbsp; （4）概要设计文档评审
</p>
<p>
    &nbsp; &nbsp; 在文档编写完成后，要对设计部分是否完整地实现了需求中规定的功能、性能等要求，设计方案的可行性，关键的处理及内外部接口定义正确性、有效性，各部分之间的一致性等进行评审，以免在以后的设计中出现大的问题而返工。
</p>
<p>
    &nbsp; &nbsp; 综上所述，概要设计的主要任务可以分为两部分，如图3-6所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    
     图3-6 概要设计的任务&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-6.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    2.结构图
</p>
<p>
    &nbsp; &nbsp; 在结构化设计方法中，常用的结构设计工具是结构图（Stucture Chart，SC），也称为程序结构图。结构图的基本图符及含义如表3-6所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    
    表3-6 结构图基本图符&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/B3-6.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 根据结构化设计思想，结构图构成的基本形式有3种：顺序形式、选择形式和重复形式。
</p>
<p>
    &nbsp; &nbsp; 图3-7（a）是最基本的调用形式——顺序形式。此外还有一些附加的符号，可以表示模块的选择调用或循环调用。
</p>
<p>
    &nbsp; &nbsp; 图3-7（b）表示当模块M中某个判定为真时调用模块A，为假时调用模块B。
</p>
<p>
    &nbsp; &nbsp; 图3-7（c）表示模块M循环调用模块A。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   
     图3-7 结构图的图形表示&nbsp;
    <img src="file:///android_asset/local_html/local_imgs/T3-7.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 结构图有4种经常使用的模块类型：传入模块、传出模块、变换模块和协调模块。其表示形式如图3-8所示，含义见表3-7。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
   
       图3-8 结构图4种模块类型
    <img src="file:///android_asset/local_html/local_imgs/T3-8.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    表3-7 结构图模块类型&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/B3-7.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 软件的结构是一种层次化的表示，它指出了软件的各个模块之间的关系，如图3-9所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    图3-9 软件结构&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-9.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 在图3-9的结构图中涉及几个术语，现简述如表3-8所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    表3-8 结构图术语&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/B3-8.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp;扇入大表示模块的复用程序高。扇出大表示模块的复杂度高，需要控制和协调过多的下级模块；但扇出过小（例如总是1）也不好。扇出过大一般是因为缺乏中间层次，应该适当增加中间层次的模块。扇出太小时可以把下级模块进一步分解成若干个子功能模块，或者合并到它的上级模块中去。
</p>
<p>
    3.面向数据流的设计方法
</p>
<p>
    &nbsp; &nbsp; 结构化设计是以结构化分析产生的数据流图为基础，按一定的步骤映射成软件结构。在需求分析阶段，用SA方法产生了数据流图。面向数据流的结构化设计（SD），能够方便地将数据流图DFD转换成程序结构图。DFD从系统的输入数据流到系统的输出数据流的一连串连续加工形成了一条信息流。下面首先介绍数据流图的不同类型，然后介绍针对不同的类型所作的处理。
</p>
<p>
    &nbsp; （1）数据流图的类型
</p>
<p>
    &nbsp; &nbsp; 数据流图的信息流可分为两种类型：变换流和事务流。相应地，数据流图有两种典型的结构形式：变换型和事务型。
</p>
<p>
    &nbsp; &nbsp; ①变换型。信息沿输入通路进入系统，同时由外部形式变换成内部形式，然后通过变换中心（也叫主加工），经加工处理以后再沿输出通路变换成外部形式离开软件系统。当数据流图具有这些特征时，这种信息流就称为变换流，这种数据流图，称为变换型数据流图。变换型数据流图可以明显地分成输入、变换中心、输出3大部分，如图3-10所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;图3-10 变换型数据流图的组成&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-10.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; ②事务型。信息沿着输入通路到达一个事务中心，事务中心根据输入信息（称为事务）的类型在若干个处理序列（称为活动流）中选择一个来执行，这种信息流称为事物流，这种数据流图，称为事务型数据流图。事务型数据流图有明显的事务中心，各活动流以事物中心为起点呈辐射状流出，如图3-11所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-11 事务型数据流图的结构&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-11.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; （2）面向数据流设计方法的设计过程
</p>
<p>
    &nbsp; &nbsp; 第1步：分析、确认数据流图的类型（是事务型还是变换型）。
</p>
<p>
    &nbsp; 第2步：说明数据流的边界。
</p>
<p>
    &nbsp; 第3步：把数据流图映射为结构图。根据数据流图的类型进行事务分析或变换分析。
</p>
<p>
    &nbsp; 第4步：根据结构化设计准则对产生的结构进行优化。
</p>
<p>
    &nbsp; &nbsp; 结构化设计过程如图3-12所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;图3-12 面向数据流方法的设计过程&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-12.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; （3）结构化设计的准则
</p>
<p>
    &nbsp; &nbsp; 大量的实践表明，以下的设计准则可以借鉴为设计的指导和对软件结构图进行优化的条件。
</p>
<p>
    &nbsp; &nbsp; ①提高模块独立性。尽量高内聚，低耦合，保持相对独立性。
</p>
<p>
    &nbsp; &nbsp;②模块规模应该适中。过大的模块往往是由于分解不充分；模块过小，则开销大于有效操作，而且模块数目过多将使系统接口复杂。
</p>
<p>
    &nbsp; &nbsp; ③深度、宽度、扇出和扇入都应适当。深度表示软件结构中控制的层数，如果层数过多则应该考虑是否有许多管理模块过于简单了，要考虑能否适当合并。较好的软件结构：顶层扇出多，中层扇出比较少，底层高扇入。
</p>
<p>
    &nbsp; &nbsp; ④模块的作用域应该在控制域之内。在一个设计得很好的系统中，所有受判定影响的模块应该都从属于作出判定的那个模块，最好局限于作出判定的那个模块本身及它的直属下级模块。
</p>
<p>
    &nbsp; &nbsp; ⑤降低模块之间接口的复杂程度。应该仔细设计模块接口，使得信息传递简单并且和模块的功能一致。
</p>
<p>
    &nbsp; &nbsp; ⑥ 设计单入口单出口的模块，不要使模块间出现内容耦合。
</p>
<p>
    &nbsp; &nbsp; ⑦模块功能应该可以预测。如果一个模块可以当作一个黑盒，也就是说，只要输入的数据相同就产生同样的输出，这个模块的功能就是可以预测的。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.3.3 详细设计
</p>
<p>
    详细设计的任务，是为软件结构图中的每一个模块确定实现算法和局部数据结构，用某种选定的表达工具表示算法和数据结构的细节。
</p>
<p>
    &nbsp; &nbsp; 常用的过程设计工具有：
</p>
<p>
    &nbsp; &nbsp; 图形工具：程序流程图、N-S图、PAD图、HIPO。
</p>
<p>
    &nbsp; &nbsp; 表格工具：判定表。
</p>
<p>
    &nbsp; &nbsp; 语言工具：PDL（伪码）。
</p>
<p>
    &nbsp; &nbsp; 本节着重介绍几种主要的过程设计工具。
</p>
<p>
    1.程序流程图（PFD）
</p>
<p>
    &nbsp; &nbsp; 程序流程图，又称程序框图，是描述程序逻辑结构的工具。它使用的符号与系统流程图的符号很多相同，但是，箭头符号代表控制流而不是数据流。
</p>
<p>
    &nbsp; &nbsp; 优点是：直观清晰、易于使用。
</p>
<p>
    &nbsp; &nbsp; 缺点是：易造成非结构化的程序结构，编码时不加限制的使用GOTO语句，导致基本控制块多入多出口，与软件设计的原则相违背；程序流程图本质上不是逐步求精的好工具，诱使过早考虑程序的控制流程，而不去考虑程序的全局结构；程序流程图不易表示数据结构。
</p>
<p>
    &nbsp; &nbsp; 程序流程图的最基本图符如图3-13所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-13 程序流程图的基本图符&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-13.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 程序流程图中使用的符号含义如下：
</p>
<p>
    &nbsp; &nbsp; (a) 选择(分支)； (b) 注释； (c) 预先定义的处理； (d) 多分支；(e) 开始或停止； (f) 准备； (g)循环上界限； (h) 循环下界限； (i) 虚线； (j) 省略符； (k) 并行方式； (l) 处理；(m) 输入/输出； (n) 连接； (o) 换页连接； (p) 控制流
</p>
<p>
    &nbsp; &nbsp; 按照结构化程序设计的要求，程序流程图构成的所有程序描述可分解为如图3-14所示的5种控制结构，它们的含义如下所述。
</p>
<p>
    &nbsp; （1）顺序型：几个连续的加工步骤依次排列构成。
</p>
<p>
    &nbsp; （2）选择型：由某个逻辑判断式的取值决定选择两个加工中的一个。
</p>
<p>
    &nbsp; （3）先判断重复型（WHILE型）：先判断循环控制条件是否成立，成立则执行循环体语句。
</p>
<p>
    &nbsp; （4）后判断重复型（UNTIL型）：重复执行某些特定的加工，直到控制条件成立。
</p>
<p>
    &nbsp; （5）多分支选择型：列举多种加工情况，根据控制变量的取值，选择执行其中之一。
</p>
<p>
    &nbsp; &nbsp; &nbsp;通过把图3-13中的5种基本结构相互组合或嵌套，可以构成任何复杂的程序流程图。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;
</p>
<p>
    &nbsp; 图3-14 程序流程图的5种基本控制结构&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-14.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    2. N-S图
</p>
<p>
    &nbsp; &nbsp; N-S图。又称为盒图，它将整个程序写在一个大框图内，这个大框图由若干个小的基本框图构成。
</p>
<p>
    &nbsp; &nbsp; 优点：所有的程序结构均用方框来表示，程序结构清晰。只能表达结构化的程序逻辑，遵守结构化程序设计的规定。
</p>
<p>
    &nbsp; &nbsp; 缺点：当程序内嵌套的层数增多时，内层的方框将越来越小，从而增加绘图的难度，并使图形的清晰性受影响。&nbsp;
</p>
<p>
    &nbsp; &nbsp; N-S图的基本图符及表示的5种基本控制结构如图3-15所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-15 N-S图的5种基本控制结构&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-15.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    3.PAD图
</p>
<p>
    &nbsp; &nbsp; PAD是问题分析图（Problem Analysis Diagram）的英文缩写，PAD图用二维树型结构的图来表示程序的控制流，将这种图翻译成程序代码比较容易。
</p>
<p>
    &nbsp; &nbsp; PAD图的优点有：
</p>
<p>
    &nbsp;（1）清晰地反映了程序的层次结构。
</p>
<p>
    &nbsp;（2）支持逐步求精的设计方法。
</p>
<p>
    &nbsp;（3）易读易写，使用方便。
</p>
<p>
    &nbsp;（4）支持结构化的程序设计原理。
</p>
<p>
    &nbsp;（5）可自动生成程序。
</p>
<p>
    &nbsp; &nbsp;PAD图的5种基本控制结构如图3-16所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-16 PAD图的5种基本控制结构&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-16.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    4. PDL
</p>
<p>
    &nbsp; &nbsp; 过程设计语言（Process Design Language）是一种用于描述模块算法设计和处理细节的语言。分内外两层语言。外层具有严格的关键字语法，内层表示实际操作和条件的自然语言，语法自由。
</p>
<p>
    &nbsp; &nbsp; 程序结构有：顺序结构、选择结构、重复结构、出口结构、扩充结构（模块定义、模块调用、数据定义、输入/输出）等。
</p>
<p>
    &nbsp; &nbsp; 与结构化语言区别：作用不同，抽象层次不同，读者也不同。
</p>
<p>
    &nbsp; &nbsp; 用PDL表示的基本控制结构的常用词汇如下所示：
</p>
<p>
    &nbsp; &nbsp; 顺序：A/A/END
</p>
<p>
    &nbsp; &nbsp; 条件：IF/THEN/ELSE/ENDIF
</p>
<p>
    &nbsp; &nbsp; 循环：DO WHILE /ENDDO，REPEAT UNTIL /ENDREPEAT
</p>
<p>
    &nbsp; &nbsp; 分支：CASE_OF/WHEN/SELECT/WHENS/ELECT/ENDCASE
</p>
<p>
    &nbsp; &nbsp; PDL语言可以由编程语言转换得到，也可以是专门为过程描述而设计的。但其应具有以下4个特征：
</p>
<p>
    &nbsp; （1）有为结构化构成元素、数据说明和模块化特征提供关键词语法；
</p>
<p>
    &nbsp; （2）处理部分的描述采用自然语言法；
</p>
<p>
    &nbsp; （3）可以说明简单和复杂的数据结构；
</p>
<p>
    &nbsp; （4）支持各种接口描述的子程序定义和调用技术。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p style="text-align: center;">
    <strong>3.4 软件测试</strong>
</p>
<p>
    3.4.1 软件测试的目的和准则
</p>
<p>
    软件测试就是在软件投入运行之前，尽可能多地发现软件中的错误。软件测试是保证软件质量、可靠性的关键步骤。它是对软件规格说明、设计和编码的最后复审。通常，软件测试的工作量往往占软件开发总工作量的40%以上。
</p>
<p>
    &nbsp; &nbsp; 本节主要讲解软件测试的目的、方法及实施方法。
</p>
<p>
    1.软件测试的目的
</p>
<p>
    &nbsp; &nbsp; Grenford.J.Myers给出了软件测试的目的。
</p>
<p>
    &nbsp; （1）测试是为了发现程序中的错误而执行程序的过程。
</p>
<p>
    &nbsp; （2）好的测试用例（test case）很可能发现迄今为止尚未发现的错误。
</p>
<p>
    &nbsp; （3）一次成功的测试是指发现了至今为止尚未发现的错误。
</p>
<p>
    &nbsp; &nbsp; 测试的目的是发现软件中的错误，但是，暴露错误并不是软件测试的最终目的，测试的根本目的是尽可能多地发现并排除软件中隐藏的错误。
</p>
<p>
    2.软件测试的准则
</p>
<p>
    &nbsp; &nbsp; 根据上述软件测试的目的，为了能设计出有效的测试方案，以及好的测试用例，软件测试人员必须深入理解，并正确运用以下软件测试的基本准则。
</p>
<p>
    &nbsp; （1）所有测试都应追溯到用户需求。
</p>
<p>
    &nbsp; （2）在测试之前制定测试计划，并严格执行。
</p>
<p>
    &nbsp; （3）充分注意测试中的群集现象。
</p>
<p>
    &nbsp; （4）避免由程序的编写者测试自己的程序。
</p>
<p>
    &nbsp; （5）不可能进行穷举测试。
</p>
<p>
    &nbsp; （6）妥善保存测试计划、测试用例、出错统计和最终分析报告，为维护提供方便。
</p>
<p>
    &nbsp; &nbsp; 说明：经验表明，测试后程序中残存的错误数目与该程序中已发现的错误数目成正比。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.4.2 软件测试方法
</p>
<p>
    软件测试具有多种方法，对于软件测试方法和技术可以从不同角度进行分类。根据软件是否需要被执行，可以分为静态测试和动态测试。如果按照功能划分，可以分为白盒测试和黑盒测试。
</p>
<p>
    1.静态测试和动态测试
</p>
<p>
    &nbsp; （1）静态测试，指测试程序采用人工检测和计算机辅助静态分析的手段对程序进行检测。包括代码检查、静态结构分析、代码质量度量等。其中代码检查分为代码审查、代码走查、桌面检查、静态分析等具体形式。
</p>
<p>
    &nbsp; （2）动态测试
</p>
<p>
    &nbsp; &nbsp; 静态测试不实际运行软件，主要通过人工进行分析。动态测试就是通常所说的上机测试，通过运行软件来检验软件中的动态行为和运行结果的正确性。
</p>
<p>
    动态测试的关键是设计高效、合理的测试用例。测试用例就是为测试设计的数据，由测试输入数据和预期的输出结果两部分组成。测试用例的设计方法一般分为两类：黑盒测试方法和白盒测试方法。
</p>
<p>
    2.黑盒测试和白盒测试
</p>
<p>
    &nbsp; （1）白盒测试
</p>
<p>
    &nbsp; &nbsp; 白盒测试是把程序看成装在一只透明的白盒子里，测试者完全了解程序的结构和处理过程。它根据程序的内部逻辑来设计测试用例，检查程序中的逻辑通路是否都按预定的要求正确地工作。
</p>
<p>
    &nbsp; （2）黑盒测试
</p>
<p>
    &nbsp; &nbsp; 黑盒测试是把程序看成一只黑盒子，测试者完全不了解，或不考虑程序的结构和处理过程。它根据规格说明书的功能来设计测试用例，检查程序的功能是否符合规格说明的要求。
</p>
<p>
    测试软件的功能是否达到预期的要求。测试主要着眼于软件的外部特性。
</p>
<p>
    3.4.3 白盒测试的测试用例设计
</p>
<p>
    白盒测试又称为结构测试或逻辑驱动测试。主要测试软件的内部结构和数据结构是否符合设计要求。它允许测试人员利用程序内部的逻辑结构及有关信息来设计或选择测试用例，对程序尽可能多的逻辑路径进行测试。
</p>
<p>
    &nbsp; &nbsp; 白盒测试的基本原则是：保证所测模块中每一独立路径至少执行一次；保证所测模块所有判断的每一分支至少执行一次；保证所测模块的每一循环都在边界条件和一般条件下至少各执行一次；验证所有内部数据结构的有效性。
</p>
<p>
    &nbsp; &nbsp; 白盒测试的主要技术有逻辑覆盖测试、基本路径测试等。
</p>
<p>
    1.逻辑覆盖测试
</p>
<p>
    &nbsp; &nbsp; 逻辑覆盖泛指一系列以程序内部的逻辑结构为基础的测试用例设计技术。程序中的逻辑表示主要有判断、分支、条件等3种表示方式。
</p>
<p>
    &nbsp; （1）语句覆盖
</p>
<p>
    &nbsp; &nbsp; 语句覆盖是指选择足够多的测试用例，使被测程序中的每个语句至少执行一次。
</p>
<p>
    &nbsp; &nbsp; 例如，用程序流程图表示的程序如图3-17所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-17 程序流程图&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-17.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 按照语句覆盖的测试要求，对图3-17的程序设计如表3-9中的测试用例1和测试用例2。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;表3-9 语句覆盖测试用例
      <img src="file:///android_asset/local_html/local_imgs/B3-9.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 语句覆盖是逻辑覆盖中基本的覆盖，尤其对单元测试来说。但是语句覆盖往往没有关注判断中的条件有可能隐含的错误。
</p>
<p>
    &nbsp; （2）路径覆盖
</p>
<p>
    &nbsp; &nbsp; 路径覆盖是指执行足够的测试用例，使程序中所有可能的路径至少经历一次。
</p>
<p>
    &nbsp; &nbsp; 例如，用程序流程图表示的程序如图3-18所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp;图3-18 程序流程图&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-18.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp;对图3-18的程序设计的一组测试用例，就可以覆盖该程序的全部4条路径：ace，abd，abe，acd，如表3-10所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; （3）判定覆盖
</p>
<p>
    &nbsp; &nbsp; 判定覆盖，它是指使测试用例每个判断的每个取值分支（T或F）至少经历一次。
</p>
<p>
    &nbsp; &nbsp; 根据判断覆盖的要求，对如图3-19所示的程序，如果其中包含条件i≥j的判断为真值和为假值的程序执行路径至少经历一次，仍然可以用条件覆盖中的测试用例3和测试用例4。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-19 程序流程图&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-19.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; &nbsp;程序每个判断中若存在多个联立条件，仅保证判断的真假值往往会导致某些单个条件的错误不能被发现。例如，某判断“x＜1或y＞5”，其中只要一个条件取值为真，无论另一个条件是否错误，判断的结果都为真。
</p>
<p>
    &nbsp; &nbsp; 这说明，仅有判断覆盖还无法保证能查出判断条件的错误，需要更强的逻辑覆盖。
</p>
<p>
    &nbsp; （4）条件覆盖
</p>
<p>
    &nbsp; &nbsp; 条件覆盖是指设计用例保证程序中每个判断的每个条件的可能取值至少执行一次。
</p>
<p>
    &nbsp; &nbsp; 例如，有程序流程图表示的程序如图3-19所示。
</p>
<p>
    &nbsp; &nbsp; 按照条件覆盖的测试要求，对图3-19的程序判断框中的条件i≥j和条件j＜8设计如表3-11所示中测试用例3和测试用例4，就能保证该条件取真值和取假值的情况至少执行一次。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;表3-11 条件覆盖测试用例
      <img src="file:///android_asset/local_html/local_imgs/B3-11.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 条件覆盖深入到判断中的每个条件，但是可能忽略全面的判断覆盖的要求。有必要考虑判断－条件覆盖。
</p>
<p>
    &nbsp; （5）判断－条件覆盖
</p>
<p>
    &nbsp; &nbsp; 判断－条件覆盖是指设计足够的测试用例，使判断中每个条件的所有可能取值至少执行一次，同时每个判断的所有可能取值分支至少执行一次。
</p>
<p>
    &nbsp; &nbsp; 例如，有程序流程图表示的程序如图3-20所示。
</p>
<p>
    &nbsp; &nbsp; 按照判断－条件覆盖的要求，对图3-20程序的两个判断框的每个取值分支至少经历一次，同时两个判断框中的3个条件的所有可能取值至少执行一次，设计如表3-12所示中3个测试用例，就能保证满足判断－条件覆盖。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-20 程序流程图
      <img src="file:///android_asset/local_html/local_imgs/T3-20.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    2.基本路径测试
</p>
<p>
    &nbsp; &nbsp; 基本路径测试的思想和步骤是：根据软件过程性描述中的控制流程确定程序的环路复杂性度量，用此度量定义基本路径集合，并由此导出一组测试用例对每一条独立执行路径进行测试。
</p>
<p>
    &nbsp; &nbsp; 例如，有程序流程图表示的程序如图3-21所示。
</p>
<p>
    &nbsp; &nbsp; 对图3-21的程序流程图确定程序的环路复杂度的方法是：环路复杂度=程序流程图中的判断框个数+1。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp;图3-21 程序流程图&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-21.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 环路复杂度的值即为要设计测试用例的基本路径数，如图3-21所示的程序环路复杂度为3，所以设计3个测试用例，覆盖的基本路径是abf，acef，acdf，如表3-13所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    表3-13 基本路径测试用例
      <img src="file:///android_asset/local_html/local_imgs/B3-13.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    &nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.4.4 黑盒测试的测试用例设计
</p>
<p>
    黑盒测试方法又称功能测试或数据驱动测试，着重测试软件功能。白盒测试在测试过程的早期阶段进行，而黑盒测试主要用于软件的确认测试。
</p>
<p>
    &nbsp; &nbsp; 黑盒测试完全不考虑程序内部的逻辑结构和处理过程，黑盒测试是在软件接口处进行，检查和验证程序的功能是否符合需求规格说明书的功能说明。
</p>
<p>
    &nbsp; &nbsp; 常用的黑盒测试方法和技术有等价类划分法、边界值分析法、错误推测法和因果图等。
</p>
<p>
    1.等价类划分法
</p>
<p>
    &nbsp; &nbsp; 等价类划分是一种常用的黑盒测试方法，这种技术的方法是先把程序的所有可能的输入划分成若干个等价类，然后根据等价类选取相应的测试用例。每个等价类中各个输入数据度发现程序中错误的几率几乎是相同的。因此，从每个等价类中只取一组数据作为测试数据，这样选取的测试数据最有代表性，最可能发现程序中的错误，并且大大减少了需要的测试数据的数量。
</p>
<p>
    2.边界值分析法
</p>
<p>
    &nbsp; &nbsp; 边界值分析法是对各种输入、输出范围的边界情况设计测试用例的方法。
</p>
<p>
    &nbsp; &nbsp; 大量的实践表明，程序在处理边界值时容易出错，因此设计一些测试用例，使程序运行在边界情况附近，这样揭露程序中错误的可能性就更大。
</p>
<p>
    &nbsp; &nbsp; 选取的测试数据应该刚好等于、小于和大于边界值。也就是说，按照边界值分析法，应该选取刚好等于、稍小于和稍大于等价类边界值的数据作为测试数据，而不是选取每个等价类内的典型值或任意值作为测试数据。
</p>
<p>
    &nbsp; &nbsp; 通常设计测试方案时总是把等价划分和边界值分析法结合使用。
</p>
<p>
    3.错误推测法
</p>
<p>
    &nbsp; （1）错误推测法概念
</p>
<p>
    &nbsp; &nbsp; 错误推测法是一种凭直觉和经验推测某些可能存在的错误，从而针对这些可能存在的错误设计测试用例的方法。这种方法没有机械的执行过程，主要依靠直觉和经验。
</p>
<p>
    &nbsp; &nbsp; 错误推测法针对性强，可以直接切入可能的错误，直接定位，是一种非常实用、有效的方法，但是需要非常丰富的经验。
</p>
<p>
    &nbsp; （2）错误推测法实施步骤
</p>
<p>
    &nbsp; &nbsp; 首先对被测试软件列出所有可能出现的错误和易错情况表，然后基于该表设计测试用例。
</p>
<p>
    &nbsp; &nbsp; 例如，输入数据为0或输出数据为0往往容易发生错误；如果输入或输出的数据允许变化，则输入或输出的数据为0和1的情况（例如，表为空或只有一项）是容易出错的情况。测试者可以设计输入值为0或1的测试情况，以及使输出强迫为0或1的测试情况。
</p>
<p>
    <br/>
</p>
<p>
    3.4.5 软件测试的实施
</p>
<p>
    软件测试是保证软件质量的重要手段之一。软件测试的实施过程主要有4个步骤：单元测试、集成测试、确认测试（验收测试）和系统测试。
</p>
<p>
    1.单元测试
</p>
<p>
    &nbsp; （1）单元测试概念
</p>
<p>
    &nbsp; &nbsp; 单元测试也称模块测试，模块是软件设计的最小单位，单元测试是对模块进行正确性的检验，以期尽早发现各模块内部可能存在的各种错误。
</p>
<p>
    &nbsp; &nbsp; 通常单元测试在编码阶段进行，单元测试的依据除了源程序以外还有详细设计说明书。
</p>
<p>
    &nbsp; &nbsp; 单元测试可以采用静态测试或者动态测试。动态测试通常以白盒测试法为主，测试其结构，以黑盒测试法为辅，测试其功能。
</p>
<p>
    &nbsp; （2）单元测试的测试环境
</p>
<p>
    &nbsp; &nbsp; 单元测试是针对单个模块，这样的模块通常不是一个独立的程序，需要考虑模块和其他模块的调用关系。在单元测试中，用一些辅助模块去模拟与被测模块相联系的其他模块，即为测试模块设计驱动模块和桩模块，构成一个模拟的执行环境进行测试，如图3-22所示。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    图3-22 单元测试的测试环境&nbsp;
      <img src="file:///android_asset/local_html/local_imgs/T3-22.jpg" style="width:100%;border-radius: 10px;">
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    &nbsp; &nbsp; 驱动（Driver）模块就相当于一个“主程序”，它接收测试数据，把这些数据传送给被测试的模块，输出有关的结果。
</p>
<p>
    &nbsp; &nbsp; 桩（Stub）模块代替被测试的模块所调用的模块。因此桩模块也可以称为“虚拟子程序”。它接受被测模块的调用，检验调用参数，模拟被调用的子模块的功能，把结果送回被测试的模块。
</p>
<p>
    &nbsp; 说明：在软件的结构图中，顶层模块测试时不需要驱动模块，最底层的模块测试时不需要桩模块。
</p>
<p>
    2.集成测试
</p>
<p>
    &nbsp; &nbsp; 集成测试也称组装测试，它是对各模块按照设计要求组装成的程序进行测试，主要目的是发现与接口有关的错误（系统测试与此类似）。集成测试主要发现设计阶段产生的错误，集成测试的依据是概要设计说明书，通常采用黑盒测试。
</p>
<p>
    &nbsp; &nbsp; 集成测试的内容包括软件单元的接口测试、全局数据结构测试、边界条件测试以及非法输入测试。
</p>
<p>
    &nbsp; &nbsp; 集成的方式可以分为非增量方式集成和增量方式集成两种。
</p>
<p>
    &nbsp; &nbsp; 非增量方式是先分别测试每个模块，再把所有模块按设计要求组装一起进行整体测试，因此，非增量方式又称一次性组装方式。增量方式是把要测试的模块同已经测试好的那些模块连接起来进行测试，测试完以后再把下一个应测试的模块连接进来测试。
</p>
<p>
    增量方式包括自顶向下、自底向上以及自顶向下和自底向上相结合的混合增量方法。
</p>
<p>
    3.确认测试
</p>
<p>
    &nbsp; &nbsp; 确认测试的任务是检查软件的功能、性能及其他特征是否与用户的需求一致，它是以需求规格说明书作为依据的测试。确认测试通常采用黑盒测试。
</p>
<p>
    &nbsp; &nbsp; 确认测试首先测试程序是否满足规格说明书所列的各项要求，然后要进行软件配置复审。复审的目的在于保证软件配置齐全、分类有序，以及软件配置所有成分的完备性、一致性、准确性和可操作性，并且包括软件维护所必需的细节。
</p>
<p>
    4.系统测试
</p>
<p>
    &nbsp; &nbsp; 在确认测试完成后，把软件系统整体作为一个元素，与计算机硬件、支持软件、数据、人员和其他计算机系统的元素组合在一起，在实际运行环境下对计算机系统进行一系列的集成测试和确认测试，这样的测试称为系统测试。
</p>
<p>
    &nbsp; &nbsp; 系统测试的目的是在真实的系统工作环境下检验软件是否能与系统正确连接，发现软件与系统需求不一致的地方。
</p>
<p>
    &nbsp; &nbsp; 系统测试的内容包括：功能测试、操作测试、配置测试、性能测试、安全性测试、外部接口测试等。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>
<p>
    <br/>
</p>

<p style="text-align: center;">
    <strong>3.5 程序的调试</strong>
</p>
<p>
    3.5.1 程序调试的基本概念
</p>
<p>
    在对程序进行了成功的测试之后将进行程序的调试。程序调试的任务是诊断和改正程序中的错误。
</p>
<p>
    &nbsp; &nbsp; 如前所述，测试是为了发现错误，成功的测试是发现了错误的测试。
</p>
<p>
    &nbsp; &nbsp; 调试（也称为Debug，排错）是作为成功测试的后果出现的步骤，也就是说，调试是在测试发现错误之后排除错误的过程。软件测试贯穿整个软件生命期，而调试主要在开发阶段。
</p>
<p>
    &nbsp; &nbsp;程序调试活动由两部分组成，即根据错误的迹象确定程序中错误的确切性质、原因和位置，从而对程序进行修改，排除这个错误。
</p>
<p>
    1.程序调试的基本步骤
</p>
<p>
    &nbsp; （1）错误定位。
</p>
<p>
    &nbsp; &nbsp; 从错误的外部表现形式入手，研究有关部分的程序，确定程序中出错位置，找出错误的内在原因。错误定位工作占据了软件调试绝大部分的工作量。
</p>
<p>
    从技术角度来看，错误的特征和查找错误的难度在于：
</p>
<p>
    &nbsp; &nbsp; ①现象和原因所处的位置可能相距很远。
</p>
<p>
    &nbsp; &nbsp; ②当纠正其他错误时，这一错误所表现出的现象可能会消失或暂时性消失，但并未从根本上消除。
</p>
<p>
    &nbsp; &nbsp; ③现象可能并不是由错误引起的（如舍入误差）。
</p>
<p>
    &nbsp; &nbsp; ④现象可能是由一些不容易发现的人为错误引起的。
</p>
<p>
    &nbsp; &nbsp; ⑤错误现象可能时有时无。
</p>
<p>
    &nbsp; &nbsp; ⑥现象是由难以再现的输入状态（例如实时应用中输入顺序不确定）引起的。
</p>
<p>
    &nbsp; &nbsp; ⑦现象可能是周期性出现的。
</p>
<p>
    &nbsp; （2）修改设计和代码，以排除错误。
</p>
<p>
    &nbsp; &nbsp; 排错是软件开发过程中的一项艰苦工作，这也决定了调试工作是一个具有很强技术性和技巧性的工作。要想找出真正的原因，排除潜在的错误不是一件简单的事。
</p>
<p>
    &nbsp; （3）进行回归测试，防止引进新的错误。
</p>
<p>
    &nbsp; &nbsp; 程序被修改以后可能会出现新的错误，重复进行暴露这个错误的原始测试或某些有关测试，来确定该错误是否被排除、是否引进了新的错误。如果所做的修正无效，则将本次修改撤销，重复以上过程直到找到可行的解决方案。
</p>
<p>
    2.程序调试的原则
</p>
<p>
    &nbsp; 调试活动由对程序中错误的定性、定位和排错两部分组成，因此调试原则也从这两个方面来考虑。
</p>
<p>
    &nbsp;（1）错误定性和定位的原则
</p>
<p>
    &nbsp; &nbsp; ①集中思考分析和错误现象有关的信息。
</p>
<p>
    &nbsp; &nbsp; ②不要钻死胡同。如果在调试中陷入困境，可以暂时放在一边，或者通过讨论寻找新的思路。
</p>
<p>
    &nbsp; &nbsp; ③不要过分信赖调试工具。调试工具只能提供一种无规律的调试方法，不能代替人思考。
</p>
<p>
    &nbsp; &nbsp; ④避免用试探法。试探法其实是碰运气的盲目动作，成功率很小，是没有办法时的办法。
</p>
<p>
    &nbsp;（2）修改错误的原则
</p>
<p>
    &nbsp; &nbsp; ①在错误出现的地方，可能还有其他错误。因为经验表明，错误有群集现象。
</p>
<p>
    &nbsp; &nbsp; ②修改错误的一个常见失误是只修改了这个错误的现象，而没有修改错误本身。如果提出的修改不能解释与这个错误有关的全部线索，这就表明只修改了错误的一部分。
</p>
<p>
    &nbsp; &nbsp; ③必须明确，修改一个错误的同时可能引入了新的错误。解决的办法是在修改了错误之后，必须进行回归测试。
</p>
<p>
    &nbsp; &nbsp; ④修改错误的过程将迫使人们暂时回到程序设计阶段。修改错误也是程序设计的一种形式，在程序设计阶段所使用的任何方法都可以应用到错误修正的过程中来。
</p>
<p>
    &nbsp; &nbsp; ⑤修改源代码程序，不要改变目标代码。&nbsp;
</p>
<p>
    <br/>
</p>
<p>
    3.5.2 软件调试方法
</p>
<p>
    调试的关键是错误定位，即推断程序中错误的位置和原因。类似于软件测试，软件调试从是否跟踪和执行程序的角度，分为静态调试和动态调试。静态调试是主要的调试手段，是指通过人的思维来分析源程序代码和排错，而动态调试是静态测试的辅助。
</p>
<p>
    1.强行排错法
</p>
<p>
    &nbsp; &nbsp; 强行排错法是寻找软件错误原因的很低效的方法，但作为传统的调试方法，目前仍经常使用。
</p>
<p>
    其过程可以概括为设置断点、程序暂停、观察程序状态和继续运行程序。
</p>
<p>
    &nbsp; &nbsp; 在使用任何一种调试方法之前，必须首先进行周密的思考，必须有明确的目的，应该尽量减少无关信息的数量。
</p>
<p>
    2.回溯法
</p>
<p>
    &nbsp; &nbsp; 回溯法是一种相当常用的调试方法，这种方法适用于调试小程序。从最先发现错误现象的地方开始，人工沿程序的控制流逆向追踪分析源程序代码，直到找出错误原因或者确定错误的范围。但是，随着程序规模扩大，应该回溯的路径数目也变得越来越大，以至彻底回溯变成完全不可能了。
</p>
<p>
    3.原因排除法
</p>
<p>
    &nbsp; 二分法、归纳法和演绎法都属于原因排除法。
</p>
<p>
    &nbsp; （1）二分法
</p>
<p>
    &nbsp; &nbsp; 二分法的基本思路是，如果已经知道每个变量在程序内若干个关键点的正确值，则可以用赋值语句或输入语句在程序中点附近给这些变量赋正确值，然后运行程序并检查所得到的输出。如果输出结果是正确的，则说明错误原因在程序的前半部分；反之，错误原因在程序的后半部分。对错误原因所在的那部分再重复使用这个方法，直到把出错范围缩小到可以诊断的程度为止。
</p>
<p>
    &nbsp; （2）归纳法
</p>
<p>
    &nbsp; &nbsp; 归纳法是从个别推断出一般的系统化思维方法。使用归纳法进行调试时，首先把和错误有关的数据组织起来进行分析，然后导出对错误原因的一个或多个假设，并利用已有的数据来证明或排除这些假设。直到寻找到潜在的原因，从而找出错误。
</p>
<p>
    &nbsp; （3）演绎法
</p>
<p>
    &nbsp; &nbsp; 演绎法是一种从一般原理或前提出发，经过排除和精化的过程推导出结论的思维方法。采用这种方法调试时，首先假设所有可能的出错原因，然后用测试来逐个排除假设的原因。如果测试表明某个假设的原因可能是真的原因，则对数据进行细化以准确定位错误。
</p>
<p>
    &nbsp; &nbsp; 上述3种方法都可以使用调试工具辅助完成，但是工具并不能代替调试人员对全部设计文档和源程序的仔细分析与评估。
</p>

</body></html>